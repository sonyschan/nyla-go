<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complete RAG Pipeline Test</title>
    <style>
        body { font-family: monospace; margin: 20px; background: #1a1a1a; color: #fff; }
        .test-section { margin: 20px 0; padding: 15px; background: #2a2a2a; border-radius: 8px; }
        .test-title { color: #ff6b35; font-weight: bold; margin-bottom: 10px; }
        .result { margin: 10px 0; padding: 10px; background: #333; border-radius: 4px; }
        .success { border-left: 4px solid #4CAF50; }
        .error { border-left: 4px solid #f44336; }
        .info { border-left: 4px solid #2196F3; }
        button { padding: 10px 20px; margin: 5px; background: #ff6b35; color: white; border: none; border-radius: 4px; cursor: pointer; }
        button:hover { background: #e55a2b; }
        pre { background: #111; padding: 10px; border-radius: 4px; overflow-x: auto; }
    </style>
</head>
<body>
    <h1>ğŸ” Complete RAG Pipeline Test</h1>
    <p>Test the complete RAG pipeline with topK alignment, cross-encoder, parent-child aggregation, and score-driven strategy.</p>

    <div class="test-section">
        <div class="test-title">ğŸ“‹ Test Configuration</div>
        <div class="result info">
            <strong>RAG Process Flow:</strong><br>
            1. BM25/Dense Retrieval: topK = 25 each<br>
            2. Working-set Fusion: topK0/1 = 12<br>
            3. Cross-encoder Reranking: topK1 = 15<br>
            4. Parent-child Aggregation: topK_parent = 3<br>
            5. Score-driven Strategy: MMR bypass if top-3 â‰¥ 0.8 similarity from same section<br>
            6. Final Results: 3 segments
        </div>
    </div>

    <div class="test-section">
        <div class="test-title">ğŸ§ª Test Cases</div>
        <button onclick="testWangChaiQuery()">Test WangChai Query (Chinese)</button>
        <button onclick="testFounderQuery()">Test Founder Query</button>
        <button onclick="testTechnicalQuery()">Test Technical Query</button>
        <button onclick="testHighSimilarityScenario()">Test High-Similarity Scenario</button>
        <div id="testResults"></div>
    </div>

    <div class="test-section">
        <div class="test-title">ğŸ“Š RAG Component Status</div>
        <div id="componentStatus"></div>
    </div>

    <!-- Load test knowledge data -->
    <script>
        // Mock vector DB for testing
        window.testKnowledgeBase = [
            {
                id: "chunk_120",
                text: "WangChai (æ—ºæŸ´) is a community-driven blockchain project focused on decentralized governance and cross-chain interoperability.",
                metadata: { source: "wangchai", section: "overview", title: "WangChai Project Overview" },
                score: 0.85
            },
            {
                id: "chunk_121", 
                text: "æ—ºæŸ´ä»£å¸æä¾›æ²»ç†åŠŸèƒ½ï¼ŒæŒæœ‰è€…å¯ä»¥å‚ä¸ç¤¾åŒºå†³ç­–å’Œææ¡ˆæŠ•ç¥¨ã€‚è¯¥é¡¹ç›®è‡´åŠ›äºæ„å»ºå»ä¸­å¿ƒåŒ–çš„é‡‘èç”Ÿæ€ç³»ç»Ÿã€‚",
                metadata: { source: "wangchai", section: "overview", title: "WangChai Tokenomics" },
                score: 0.83
            },
            {
                id: "chunk_125",
                text: "WangChai partnerships include major DeFi protocols and cross-chain infrastructure providers to enhance ecosystem connectivity.",
                metadata: { source: "wangchai", section: "partnerships", title: "WangChai Partnerships" },
                score: 0.81
            },
            {
                id: "chunk_001",
                text: "NYLA Go was founded by Sony Chan, who serves as the primary developer and architect of the project.",
                metadata: { source: "team", section: "founders", title: "NYLA Founders" },
                score: 0.90
            },
            {
                id: "chunk_002",
                text: "The NYLA team consists of experienced blockchain developers and designers focused on user experience.",
                metadata: { source: "team", section: "founders", title: "NYLA Team" },
                score: 0.75
            }
        ];

        // Check component availability
        function checkComponentStatus() {
            const components = {
                'Cross-Encoder': 'NYLACrossEncoder',
                'Parent-Child Aggregator': 'NYLAParentChildAggregator', 
                'MMR Reranker': 'NYLAMMRReranker',
                'Semantic Retriever': 'NYLASemanticRetriever'
            };

            const statusHTML = [];
            for (const [name, className] of Object.entries(components)) {
                const available = typeof window[className] === 'function';
                const status = available ? 'âœ…' : 'âŒ';
                const color = available ? '#4CAF50' : '#f44336';
                statusHTML.push(`<div style="color: ${color}; margin: 5px 0;">${status} ${name}: ${available ? 'Available' : 'Not Available'}</div>`);
            }
            
            document.getElementById('componentStatus').innerHTML = statusHTML.join('');
        }

        // Mock semantic retriever for testing
        class MockSemanticRetriever {
            constructor() {
                this.options = {
                    topK: 25,
                    crossEncoderTopK: 15,
                    fusionTopK: 12,
                    parentTopK: 3,
                    finalTopK: 3,
                    highSimilarityThreshold: 0.8
                };
            }

            async retrieve(query) {
                console.log(`ğŸ” Mock retrieval for: "${query}"`);
                
                // Filter relevant chunks based on query
                let results = window.testKnowledgeBase.filter(chunk => {
                    const queryLower = query.toLowerCase();
                    const textLower = chunk.text.toLowerCase();
                    
                    // Simple relevance scoring
                    if (queryLower.includes('wangchai') || queryLower.includes('æ—ºæŸ´')) {
                        return chunk.metadata.source === 'wangchai';
                    }
                    if (queryLower.includes('founder') || queryLower.includes('åˆ›åŠäºº')) {
                        return chunk.metadata.section === 'founders';
                    }
                    
                    return textLower.includes(queryLower) || queryLower.includes(textLower.split(' ')[0]);
                }).map(chunk => ({
                    ...chunk,
                    finalScore: chunk.score
                }));

                // Simulate the complete RAG pipeline
                console.log(`ğŸ“¦ Initial results: ${results.length} chunks`);

                // Step 1: Working-set fusion
                results = this.applyWorkingSetFusion(results, this.options.fusionTopK);

                // Step 2: Cross-encoder reranking
                if (window.NYLACrossEncoder) {
                    const crossEncoder = new window.NYLACrossEncoder();
                    results = await crossEncoder.rerank(query, results, this.options.crossEncoderTopK);
                    console.log(`ğŸ¯ Cross-encoder results: ${results.length} chunks`);
                }

                // Step 3: Parent-child aggregation
                if (window.NYLAParentChildAggregator) {
                    const aggregator = new window.NYLAParentChildAggregator();
                    results = await aggregator.aggregateToParents(results, this.options.parentTopK);
                    console.log(`ğŸ—ï¸ Parent-child results: ${results.length} parent blocks`);
                }

                // Step 4: Score-driven strategy
                results = await this.applyScoreDrivenStrategy(results, query);

                return results;
            }

            applyWorkingSetFusion(results, fusionTopK) {
                const fused = results
                    .sort((a, b) => (b.finalScore || 0) - (a.finalScore || 0))
                    .slice(0, fusionTopK);
                console.log(`ğŸ”— Working-set fusion: ${results.length} â†’ ${fused.length}`);
                return fused;
            }

            async applyScoreDrivenStrategy(results, query) {
                if (results.length < 3) return results;

                const top3 = results.slice(0, 3);
                const allHighSimilarity = top3.every(r => 
                    (r.crossEncoderScore || r.aggregatedScore || r.finalScore || 0) >= this.options.highSimilarityThreshold
                );
                
                const sameSection = this.checkSameSection(top3);

                if (allHighSimilarity && sameSection) {
                    console.log('ğŸ¯ Score-driven: Bypassing MMR (high similarity + same section)');
                    return results.slice(0, this.options.finalTopK).map(r => ({
                        ...r,
                        bypassedMMR: true
                    }));
                } else {
                    console.log('ğŸ”„ Score-driven: Applying MMR for diversity');
                    // Mock MMR application
                    return results.slice(0, this.options.finalTopK);
                }
            }

            checkSameSection(results) {
                if (results.length === 0) return false;
                const firstSection = results[0].metadata?.section;
                return results.every(r => r.metadata?.section === firstSection);
            }
        }

        // Test functions
        async function testWangChaiQuery() {
            await runTest("WangChai Chinese Query", "è·Ÿæˆ‘èªªèªªæ—ºæŸ´é€™å€‹é …ç›®", {
                expectedChunks: ['chunk_120', 'chunk_121'],
                expectedHighSimilarity: true,
                expectedSameSection: true
            });
        }

        async function testFounderQuery() {
            await runTest("Founder Query", "èª°æ˜¯ NYLA å‰µè¾¦äººï¼Ÿ", {
                expectedChunks: ['chunk_001'],
                expectedHighSimilarity: false,
                expectedSameSection: true
            });
        }

        async function testTechnicalQuery() {
            await runTest("Technical Query", "blockchain development", {
                expectedChunks: ['chunk_002'],
                expectedHighSimilarity: false,
                expectedSameSection: false
            });
        }

        async function testHighSimilarityScenario() {
            await runTest("High Similarity Scenario", "WangChai project overview", {
                expectedChunks: ['chunk_120', 'chunk_121', 'chunk_125'],
                expectedHighSimilarity: true,
                expectedSameSection: false
            });
        }

        async function runTest(testName, query, expectations) {
            const startTime = Date.now();
            const testResults = document.getElementById('testResults');
            
            try {
                const retriever = new MockSemanticRetriever();
                const results = await retriever.retrieve(query);
                const latency = Date.now() - startTime;

                const resultHTML = `
                    <div class="result success">
                        <strong>âœ… ${testName}</strong><br>
                        <strong>Query:</strong> "${query}"<br>
                        <strong>Results:</strong> ${results.length} chunks<br>
                        <strong>Latency:</strong> ${latency}ms<br>
                        <strong>Top Result:</strong> ${results[0]?.id || 'None'} (Score: ${(results[0]?.crossEncoderScore || results[0]?.finalScore || 0).toFixed(3)})<br>
                        <strong>MMR Bypassed:</strong> ${results[0]?.bypassedMMR ? 'Yes' : 'No'}<br>
                        <pre>${JSON.stringify(results.map(r => ({
                            id: r.id,
                            score: (r.crossEncoderScore || r.aggregatedScore || r.finalScore || 0).toFixed(3),
                            method: r.crossEncoderMethod || 'unknown',
                            isParent: r.isParentBlock || false,
                            bypassedMMR: r.bypassedMMR || false
                        })), null, 2)}</pre>
                    </div>
                `;
                
                testResults.innerHTML += resultHTML;
            } catch (error) {
                const errorHTML = `
                    <div class="result error">
                        <strong>âŒ ${testName} Failed</strong><br>
                        <strong>Query:</strong> "${query}"<br>
                        <strong>Error:</strong> ${error.message}<br>
                        <pre>${error.stack}</pre>
                    </div>
                `;
                testResults.innerHTML += errorHTML;
            }
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            console.log('ğŸ§ª RAG Pipeline Test initialized');
            checkComponentStatus();
        });
    </script>

    <!-- Load RAG components (only what's needed for testing) -->
    <script src="js/rag/nyla-cross-encoder.js"></script>
    <script src="js/rag/nyla-parent-child-aggregator.js"></script>
</body>
</html>